Создание клиента
Перед началом работы с API Telegram вам необходимо получить собственный API ID и хеш:

Перейдите по этой ссылке и войдите в систему, используя свой номер телефона.
https://my.telegram.org/
Перейдите в раздел «Инструменты разработки API».
Откроется окно « Создать новое приложение» . Заполните данные вашего приложения. Вводить URL-адрес не нужно , и в настоящее время можно изменить только первые два поля ( название приложения и краткое название ).
В конце нажмите «Создать приложение» . Помните, что ваш API-хеш является секретным , и Telegram не позволит вам его отозвать. Не публикуйте его нигде!
Как только это будет готово, следующим шагом будет создание класса TelegramClient. Этот класс станет вашим основным интерфейсом для взаимодействия с API Telegram, и создать его очень просто:

from telethon import TelegramClient

# Use your own values here
api_id = 12345
api_hash = '0123456789abcdef0123456789abcdef'

client = TelegramClient('some_name', api_id, api_hash)
Обратите внимание, что это 'some_name'будет использоваться для сохранения вашей сессии (постоянной информации, такой как ключ доступа и другие данные) на 'some_name.session'вашем диске. По умолчанию это файл базы данных, использующий Python sqlite3.

Примечание

Важно, чтобы библиотека всегда обращалась к одному и тому же файлу сессии, чтобы вам не приходилось снова и снова отправлять код. По умолчанию файл создается в вашей рабочей директории, но абсолютные пути тоже подойдут.

Перед использованием клиента необходимо подключиться к Telegram. Сделать это очень просто:

client.connect()  # Must return True, otherwise, try again
Возможно, у вас уже есть авторизация, а возможно, и нет. Для отправки любого запроса необходимо получить авторизацию.

client.is_user_authorized()  # Returns True if you can send requests
Если у вас нет разрешения, вам необходимо .sign_in():

phone_number = '+34600000000'
client.send_code_request(phone_number)
myself = client.sign_in(phone_number, input('Enter code: '))
# If .sign_in raises PhoneNumberUnoccupiedError, use .sign_up instead
# If .sign_in raises SessionPasswordNeeded error, call .sign_in(password=...)
# You can import both exceptions from telethon.errors.
Примечание

Если вы отправите код, присланный Telegram, через само приложение, он немедленно истечет. Однако вы все еще можете отправить код через приложение, «обфусцировав» его (например, добавив магическую константу, 12345а затем вычтя ее, чтобы получить настоящий код) или используя любой другой метод.

myself— это ваш пользователь Telegram. Вы можете просмотреть всю информацию о себе, выполнив команду ` print(myself.stringify()).`. Теперь вы готовы использовать клиент по своему усмотрению! Помните, что любой объект, возвращаемый API, имеет указанный .stringify()метод, и вывод этих методов может оказаться полезным.

В качестве полного примера:

client = TelegramClient('anon', api_id, api_hash)
assert client.connect()
if not client.is_user_authorized():
    client.send_code_request(phone_number)
    me = client.sign_in(phone_number, input('Enter code: '))
Однако всё это можно сделать с помощью вызова .start():

client = TelegramClient('anon', api_id, api_hash)
client.start()
Приведённый код — это лишь то, что .start()будет происходить за кулисами (с несколькими дополнительными проверками), чтобы вы знали, как подписаться, если input()по какой-либо причине захотите избежать использования (по умолчанию). Если номер телефона или токен бота не предоставлены, вас попросят их ввести через input(). Метод также принимает параметры phone=и bot_token.

Вы можете использовать любой из них, оба подойдут. Выбор зависит только от ваших предпочтений и необходимой степени контроля.

Помните, что вы можете получить доступ к информации в любое время client.get_me().

Предупреждение

Обратите внимание, что если вы не сможете войти в систему около 5 раз (или измените первый параметр TelegramClient, который является именем сессии), вы получите уведомление FloodWaitErrorпримерно на 22 часа, поэтому будьте внимательны и не ошибитесь! Однако этого не должно произойти, если вы будете делать все, как описано.

Примечание

Если вы хотите использовать прокси , вам необходимо установить PySocks (через pip или вручную), а затем задать соответствующие параметры:

import socks
client = TelegramClient('session_id',
    api_id=12345, api_hash='0123456789abcdef0123456789abcdef',
    proxy=(socks.SOCKS5, 'localhost', 4444)
)
В качестве аргумента proxy=следует использовать кортеж, список или словарь, состоящий из параметров, описанных здесь .

Двухфакторная аутентификация (2FA)
Если в вашей учетной записи включена двухфакторная аутентификация (далее – 2FA), вызов функции telethon.TelegramClient.sign_in()вызовет ошибку SessionPasswordNeededError. В этом случае просто telethon.TelegramClient.sign_in()повторите вызов с помощью команды password=:

import getpass
from telethon.errors import SessionPasswordNeededError

client.sign_in(phone)
try:
    client.sign_in(code=input('Enter code: '))
except SessionPasswordNeededError:
    client.sign_in(password=getpass.getpass())
Указанный .start()метод также справится с этой задачей, но вам необходимо password=предварительно задать параметр (он не будет запрашиваться).

Если у вас не включена двухфакторная аутентификация, но вы хотите настроить её через библиотеку, используйте client.edit_2fa()эту функцию. Убедитесь, что вы понимаете, что делаете, и у вас не возникнет проблем. Обратите внимание, что если вы хотите установить только адрес электронной почты/подсказку и оставить текущий пароль без изменений, вам нужно будет «повторить» двухфакторную аутентификацию.

См. примеры ниже:

from telethon.errors import EmailUnconfirmedError

# Sets 2FA password for first time:
client.edit_2fa(new_password='supersecurepassword')

# Changes password:
client.edit_2fa(current_password='supersecurepassword',
                new_password='changedmymind')

# Clears current password (i.e. removes 2FA):
client.edit_2fa(current_password='changedmymind', new_password=None)

# Sets new password with recovery email:
try:
    client.edit_2fa(new_password='memes and dreams',
                    email='JohnSmith@example.com')
    # Raises error (you need to check your email to complete 2FA setup.)
except EmailUnconfirmedError:
    # You can put email checking code here if desired.
    pass

# Also take note that unless you remove 2FA or explicitly
# give email parameter again it will keep the last used setting

# Set hint after already setting password:
client.edit_2fa(current_password='memes and dreams',
                new_password='memes and dreams',
                hint='It keeps you alive')